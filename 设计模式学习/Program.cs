using System;

namespace 设计模式学习
{
    class Program
    {
        static void Main(string[] args)
        {
            //https://www.cnblogs.com/zhili/p/DesignPatternSummery.html  设计模式总和
            //当你的项目发现有如下问题之一时，就需要考虑重构代码，可能会有某种模式适合。
            //1、代码无法进行单元测试。
            //2、需求的变动总是导致代码的变动。
            //3、有重复代码的存在。
            //4、继承层次过多。
            //5、隐藏的依赖过多。



            //设计模式的原则
            //使用设计模式的根本原因是适应变化，提高代码复用率，使软件更具有可维护性和可扩展性。
            //并且，在进行设计的时候，也需要遵循以下几个原则：
            //①单一职责原则
            //就一个类而言，应该仅有一个引起它变化的原因。简单的说，就是一个类只负责一项职责（功能）。

            //②开放封闭原则
            //软件实体（类，方法，模块）应该可以扩展，但是不可以修改。

            //③依赖倒置原则
            //针对抽象编程，不要针对实现编程；高层模块不应该依赖于底层模块，两个模块都应该依赖于抽象(抽象类 / 接口)。

            //④里氏代替原则
            //1.一个软件实体如果使用的是一个父类的话，那么一定适用于其子类。而且它察觉不出父类对象和子类对象的区别。
            //2.在软件里面，把父类都替换成它的子类，软件的行为没有变化；简单点说，子类型必须能够替换掉它们的父类型。

            //⑤接口隔离原则
            //使用多个专门的接口比使用单一的总接口要好。
            //也就是说不要让一个单一的接口承担过多的职责，而应把每个职责分离到多个专门的接口中，进行接口分离。
            //过于臃肿的接口是对接口的一种污染。

            //⑥迪米特原则
            //1.如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。
            //如果其中一个类需要调用另外一个类的某一个方法的话，可以通过第三者转发这个调用。
            //2.一个对象应当对其他对象有尽可能少的了解。
            //3.迪米特原则主要是强调了类与类之间的松耦合。
            //类与类之间的耦合度越低，越有利于代码的复用，一个处于低耦合的类被修改了，不会对有关系的类造成影响。

            //⑦合成复用原则
            //在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分。
            //新对象通过向这些对象的委派达到复用已用功能的目的。



            //常见设计模式


            //创建型模式

            //工厂模式：
            //提供了一种将对象的创建过程与使用过程分离的方式。
            //通过定义一个工厂类，使得客户端代码可以从工厂类中获取所需的对象，而无需知道对象的具体创建过程。

            //单例模式：
            //保证一个类只有一个实例，并提供了全局访问该实例的方式。


            //行为型模式

            //观察者模式：
            //定义了一种一对多的依赖关系，使得多个观察者对象可以同时监听某个主题对象的状态变化。

            //策略模式：
            //定义了一系列算法，将每个算法都封装起来，并且使它们之间可以互换。
        }
    }
}
